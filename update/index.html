<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sincronizador Inteligente - RenovaWeb</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .fa-spinner { animation: spin 1s linear infinite; }
        
        /* Cores de Status */
        .status-updated { color: #10b981; } /* Verde */
        .status-outdated { color: #f59e0b; } /* Laranja */
        .status-missing { color: #a855f7; }  /* Roxo */
        .status-untracked { color: #6b7280; } /* Cinza */
        .status-error { color: #ef4444; }    /* Vermelho */

        /* Animação do Modal */
        .modal-enter { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen p-6">

    <div class="max-w-7xl mx-auto relative z-0">
        <!-- Header -->
        <header class="mb-8 border-b border-gray-700 pb-4">
            <h1 class="text-3xl font-bold text-blue-400 mb-2">
                <i class="fa-solid fa-sync mr-2"></i> Sincronizador RenovaWeb
            </h1>
            <p class="text-gray-400">
                A estrutura de arquivos é ditada pelo arquivo <code>paths.json</code> remoto.
                <br>
                Base: <code class="bg-gray-800 px-2 py-1 rounded text-yellow-500 text-sm">https://extensions.io.log.br/renovaweb/...</code>
            </p>
        </header>

        <!-- Controles -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-6 border border-gray-700">
            <div class="flex flex-col md:flex-row gap-4 items-center justify-between">
                
                <div class="flex-1 w-full space-y-2">
                    <button id="btnSelectDir" class="w-full md:w-auto bg-blue-600 hover:bg-blue-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <i class="fa-solid fa-folder-open"></i> Selecionar Pasta Local
                    </button>
                    
                    <button id="btnRestoreDir" class="hidden w-full md:w-auto bg-purple-600 hover:bg-purple-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors items-center justify-center gap-2">
                        <i class="fa-solid fa-folder-tree"></i> Restaurar Acesso à Pasta Anterior
                    </button>

                    <p id="selectedPathDisplay" class="text-sm text-gray-400 italic">Nenhum diretório selecionado</p>
                </div>

                <div class="flex flex-wrap gap-3 justify-end">
                    <button id="btnCheckAll" disabled class="disabled:opacity-50 disabled:cursor-not-allowed bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded border border-gray-600">
                        <i class="fa-solid fa-cloud-download-alt"></i> 1. Buscar Lista & Comparar
                    </button>
                    
                    <button id="btnUpdateAll" disabled class="disabled:opacity-50 disabled:cursor-not-allowed bg-indigo-600 hover:bg-indigo-500 text-white py-2 px-4 rounded border border-indigo-600 shadow-lg shadow-indigo-900/50 font-bold">
                        <i class="fa-solid fa-sync"></i> 2. Sincronizar Tudo
                    </button>

                    <button id="btnDownloadZip" disabled class="disabled:opacity-50 disabled:cursor-not-allowed bg-green-700 hover:bg-green-600 text-white py-2 px-4 rounded border border-green-600 shadow-lg shadow-green-900/50">
                        <i class="fa-solid fa-file-zipper"></i> Baixar ZIP
                    </button>
                </div>
            </div>
        </div>

        <!-- Tabela de Arquivos -->
        <div class="bg-gray-800 rounded-lg shadow-lg overflow-hidden border border-gray-700">
            <div class="overflow-x-auto">
                <table class="w-full text-left border-collapse text-sm">
                    <thead>
                        <tr class="bg-gray-900 text-gray-400 uppercase tracking-wider">
                            <th class="p-4 border-b border-gray-700">Arquivo (Baseado em paths.json)</th>
                            <th class="p-4 border-b border-gray-700 w-48">Data Local</th>
                            <th class="p-4 border-b border-gray-700 w-48">Data Nuvem</th>
                            <th class="p-4 border-b border-gray-700 w-32 text-center">Status</th>
                            <th class="p-4 border-b border-gray-700 w-32 text-center">Ação</th>
                        </tr>
                    </thead>
                    <tbody id="fileListBody" class="divide-y divide-gray-700">
                        <tr>
                            <td colspan="5" class="p-8 text-center text-gray-500">
                                Selecione um diretório para iniciar.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- Footer -->
            <div class="p-4 bg-gray-900 border-t border-gray-700 text-xs text-gray-500 flex justify-between">
                <span id="fileCount">0 arquivos</span>
                <span id="logStatus">Aguardando...</span>
            </div>
        </div>
    </div>

    <!-- MODAL DE SISTEMA -->
    <div id="appModal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm p-4">
        <div class="bg-gray-800 rounded-xl shadow-2xl border border-gray-600 max-w-md w-full modal-enter transform transition-all">
            <!-- Cabeçalho -->
            <div class="flex items-center justify-between p-4 border-b border-gray-700">
                <h3 id="modalTitle" class="text-xl font-bold text-white">Confirmação</h3>
                <button onclick="closeModal()" class="text-gray-400 hover:text-white transition-colors">
                    <i class="fa-solid fa-xmark fa-lg"></i>
                </button>
            </div>
            
            <!-- Corpo -->
            <div class="p-6">
                <p id="modalMessage" class="text-gray-300 text-base leading-relaxed">
                    Mensagem do sistema aqui.
                </p>
            </div>

            <!-- Rodapé / Botões -->
            <div class="p-4 border-t border-gray-700 flex justify-end gap-3 bg-gray-800/50 rounded-b-xl">
                <button id="modalBtnCancel" class="px-4 py-2 rounded text-gray-300 hover:bg-gray-700 transition-colors font-medium">
                    Cancelar
                </button>
                <button id="modalBtnConfirm" class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 text-white font-bold shadow-lg shadow-blue-900/50 transition-colors">
                    Confirmar
                </button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        const BASE_URL = "https://extensions.io.log.br/renovaweb/";
        
        let rootDirectoryHandle = null;
        let filesData = [];
        let localFilesMap = new Map();

        // DOM Elements
        const btnSelectDir = document.getElementById('btnSelectDir');
        const btnRestoreDir = document.getElementById('btnRestoreDir');
        const btnCheckAll = document.getElementById('btnCheckAll');
        const btnUpdateAll = document.getElementById('btnUpdateAll');
        const btnDownloadZip = document.getElementById('btnDownloadZip');
        const fileListBody = document.getElementById('fileListBody');
        const selectedPathDisplay = document.getElementById('selectedPathDisplay');
        const fileCountSpan = document.getElementById('fileCount');
        const logStatusSpan = document.getElementById('logStatus');

        // Modal Elements
        const appModal = document.getElementById('appModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalBtnCancel = document.getElementById('modalBtnCancel');
        const modalBtnConfirm = document.getElementById('modalBtnConfirm');

        // Events
        btnSelectDir.addEventListener('click', handleDirectorySelection);
        btnRestoreDir.addEventListener('click', restoreDirectoryAccess);
        btnCheckAll.addEventListener('click', checkAllRemoteFiles);
        btnUpdateAll.addEventListener('click', syncFiles);
        btnDownloadZip.addEventListener('click', downloadAllAsZip);

        // --- UI Helper Functions (MODAL) ---

        let modalResolver = null;

        function closeModal() {
            appModal.classList.add('hidden');
            if (modalResolver) modalResolver(false); // Default to false if closed via X
            modalResolver = null;
        }

        // Função Genérica para mostrar o Modal
        function showModal({ title, message, type = 'alert', confirmText = 'OK', cancelText = 'Cancelar' }) {
            return new Promise((resolve) => {
                modalResolver = resolve;
                
                modalTitle.textContent = title;
                modalMessage.innerHTML = message.replace(/\n/g, '<br>'); // Suporta quebras de linha
                modalBtnConfirm.textContent = confirmText;
                modalBtnCancel.textContent = cancelText;

                // Configuração baseada no tipo
                if (type === 'confirm') {
                    modalBtnCancel.classList.remove('hidden');
                    
                    modalBtnCancel.onclick = () => {
                        appModal.classList.add('hidden');
                        resolve(false);
                    };
                    
                    modalBtnConfirm.onclick = () => {
                        appModal.classList.add('hidden');
                        resolve(true);
                    };
                    modalBtnConfirm.className = "px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 text-white font-bold shadow-lg shadow-blue-900/50 transition-colors";

                } else if (type === 'danger') {
                    // Confirmação perigosa (ex: sobrescrever)
                    modalBtnCancel.classList.remove('hidden');
                    modalBtnCancel.onclick = () => { appModal.classList.add('hidden'); resolve(false); };
                    modalBtnConfirm.onclick = () => { appModal.classList.add('hidden'); resolve(true); };
                    modalBtnConfirm.className = "px-4 py-2 rounded bg-red-600 hover:bg-red-500 text-white font-bold shadow-lg shadow-red-900/50 transition-colors";

                } else {
                    // Alert simples
                    modalBtnCancel.classList.add('hidden');
                    modalBtnConfirm.onclick = () => {
                        appModal.classList.add('hidden');
                        resolve(true);
                    };
                    modalBtnConfirm.className = "px-4 py-2 rounded bg-gray-600 hover:bg-gray-500 text-white font-bold shadow transition-colors";
                }

                appModal.classList.remove('hidden');
            });
        }

        async function showAlert(message, title = "Aviso") {
            await showModal({ title, message, type: 'alert' });
        }

        async function showConfirm(message, title = "Confirmação") {
            return await showModal({ title, message, type: 'confirm', confirmText: 'Sim', cancelText: 'Não' });
        }

        // --- IndexedDB Logic ---
        const DB_NAME = 'R2SyncDB';
        const STORE_NAME = 'handles';

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e.target.error);
            });
        }

        async function saveHandle(handle) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            tx.objectStore(STORE_NAME).put(handle, 'root'); 
        }

        async function getSavedHandle() {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const request = tx.objectStore(STORE_NAME).get('root');
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        window.addEventListener('load', async () => {
            try {
                const saved = await getSavedHandle();
                if (saved) {
                    btnSelectDir.classList.add('hidden');
                    btnRestoreDir.classList.remove('hidden');
                    selectedPathDisplay.textContent = `Pasta Salva: /${saved.name} (Requer confirmação)`;
                    rootDirectoryHandle = saved;
                }
            } catch (e) { console.error("DB Error", e); }
        });

        // --- Core Functions ---

        async function handleDirectorySelection() {
            try {
                rootDirectoryHandle = await window.showDirectoryPicker();
                await saveHandle(rootDirectoryHandle);
                await initializeDirectoryView();
            } catch (err) {
                if (err.name !== 'AbortError') await showAlert("Erro ao selecionar diretório: " + err.message, "Erro");
            }
        }

        async function restoreDirectoryAccess() {
            if (!rootDirectoryHandle) return;
            
            // Nota: O prompt de permissão do navegador é NATIVO e não pode ser substituído por HTML.
            // Mas podemos avisar antes.
            await showAlert("O navegador solicitará permissão para visualizar e editar os arquivos nesta pasta.\nPor favor, clique em 'Visualizar/Editar arquivos' no próximo aviso.", "Permissão de Segurança");

            const options = { mode: 'readwrite' };
            if ((await rootDirectoryHandle.queryPermission(options)) !== 'granted') {
                if ((await rootDirectoryHandle.requestPermission(options)) !== 'granted') {
                    await showAlert('Permissão negada pelo usuário. Não é possível continuar.', "Acesso Negado");
                    return;
                }
            }
            await initializeDirectoryView();
        }

        async function initializeDirectoryView() {
            btnSelectDir.classList.remove('hidden');
            btnRestoreDir.classList.add('hidden');
            selectedPathDisplay.textContent = `Pasta Raiz: /${rootDirectoryHandle.name}`;
            selectedPathDisplay.classList.add('text-green-400');
            selectedPathDisplay.classList.remove('text-gray-400');

            filesData = [];
            localFilesMap.clear();
            fileListBody.innerHTML = `<tr><td colspan="5" class="p-8 text-center text-blue-300">Diretório selecionado.<br>Clique em <strong>"Buscar Lista & Comparar"</strong> para ler paths.json.</td></tr>`;
            
            btnCheckAll.disabled = false;
            btnUpdateAll.disabled = true;
            btnDownloadZip.disabled = true;
            log("Aguardando verificação com a nuvem...");
        }

        async function mapLocalFiles(dirHandle, currentPath) {
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file') {
                    const fullPath = `${currentPath}/${entry.name}`;
                    const fileObj = await entry.getFile();
                    localFilesMap.set(fullPath, {
                        handle: entry,
                        lastModified: fileObj.lastModified,
                        size: fileObj.size
                    });
                } else if (entry.kind === 'directory') {
                    await mapLocalFiles(entry, `${currentPath}/${entry.name}`);
                }
            }
        }

        async function checkAllRemoteFiles() {
            btnCheckAll.disabled = true;
            btnUpdateAll.disabled = true;
            btnDownloadZip.disabled = true;
            filesData = [];
            localFilesMap.clear();
            
            log("1/3: Mapeando arquivos locais...");
            renderTableLoading("Mapeando arquivos locais...");
            
            try {
                await mapLocalFiles(rootDirectoryHandle, rootDirectoryHandle.name);
            } catch (e) {
                console.error("Erro leitura local:", e);
                await showAlert("Erro ao ler arquivos locais: " + e.message, "Erro");
            }

            log("2/3: Buscando paths.json remoto...");
            
            let pathsTree = [];
            try {
                const pathsUrl = `${BASE_URL}${rootDirectoryHandle.name}/paths.json`;
                const pathsResp = await fetch(pathsUrl, { cache: 'no-cache' });
                
                if (pathsResp.ok) {
                    const pathsData = await pathsResp.json();
                    if (pathsData.tree && Array.isArray(pathsData.tree)) {
                        pathsTree = pathsData.tree;
                        log(`Lista carregada. ${pathsTree.length} itens.`);
                    } else {
                        throw new Error("paths.json inválido.");
                    }
                } else {
                    throw new Error(`paths.json não encontrado (${pathsResp.status})`);
                }
            } catch (e) {
                console.error(e);
                renderTable(); 
                btnCheckAll.disabled = false;
                await showAlert(`Não foi possível obter paths.json da nuvem.\nVerifique: ${BASE_URL}${rootDirectoryHandle.name}/paths.json\n\nErro: ${e.message}`, "Erro de Conexão");
                return;
            }

            log("3/3: Cruzando dados...");

            for (const relPath of pathsTree) {
                const fullLocalPath = `${rootDirectoryHandle.name}/${relPath}`;
                const remoteUrl = `${BASE_URL}${fullLocalPath}`;
                const localData = localFilesMap.get(fullLocalPath);
                
                if (localData) localFilesMap.delete(fullLocalPath);

                filesData.push({
                    id: crypto.randomUUID(),
                    localPath: fullLocalPath,
                    handle: localData ? localData.handle : null,
                    remoteUrl: remoteUrl,
                    status: 'pending',
                    localDate: localData ? new Date(localData.lastModified) : null,
                    remoteDate: null,
                    remoteBlob: null,
                    httpStatus: null,
                    isMissingLocally: !localData
                });
            }

            for (const [path, data] of localFilesMap) {
                if (path.endsWith('paths.json')) continue; 
                filesData.push({
                    id: crypto.randomUUID(),
                    localPath: path,
                    handle: data.handle,
                    remoteUrl: `${BASE_URL}${path}`, 
                    status: 'untracked',
                    localDate: new Date(data.lastModified),
                    remoteDate: null,
                    remoteBlob: null,
                    httpStatus: null,
                    isMissingLocally: false
                });
            }

            const promises = filesData
                .filter(f => f.status !== 'untracked')
                .map(file => checkSingleFile(file));
            
            await Promise.all(promises);

            renderTable();
            
            const syncNeeded = filesData.some(f => f.status === 'outdated' || f.status === 'missing');
            const hasDownloads = filesData.some(f => f.remoteBlob !== null);

            if (syncNeeded) {
                btnUpdateAll.disabled = false;
                const count = filesData.filter(f => f.status === 'outdated' || f.status === 'missing').length;
                log(`Pronto. ${count} arquivos requerem atenção.`);
            } else {
                log("Sistema sincronizado.");
            }

            if (hasDownloads) btnDownloadZip.disabled = false;
            
            fileCountSpan.textContent = `${filesData.length} arquivos listados`;
            btnCheckAll.disabled = false;
        }

        async function checkSingleFile(fileObj) {
            fileObj.status = 'checking';
            
            try {
                const response = await fetch(fileObj.remoteUrl, { method: 'GET', cache: 'no-cache' });
                fileObj.httpStatus = response.status;

                if (response.ok) {
                    fileObj.remoteBlob = await response.blob();
                    
                    const lm = response.headers.get('Last-Modified');
                    if (lm) fileObj.remoteDate = new Date(lm);

                    if (fileObj.isMissingLocally) {
                        fileObj.status = 'missing';
                    } else {
                        if (fileObj.remoteDate && fileObj.localDate && fileObj.remoteDate > fileObj.localDate) {
                            fileObj.status = 'outdated';
                        } else {
                            fileObj.status = 'current';
                        }
                    }
                } else {
                    fileObj.status = 'error';
                }
            } catch (error) {
                console.warn(`Erro fetch ${fileObj.remoteUrl}:`, error);
                fileObj.status = 'error';
                fileObj.httpStatus = 'NET';
            }
        }

        async function syncFiles() {
            const toUpdate = filesData.filter(f => f.status === 'outdated' || f.status === 'missing');
            if (toUpdate.length === 0) return;
            
            const confirmed = await showConfirm(
                `Confirmar sincronização de ${toUpdate.length} arquivos?\n\nArquivos locais serão sobrescritos pelas versões da nuvem.`,
                "Iniciar Sincronização"
            );

            if(!confirmed) return;

            log(`Sincronizando ${toUpdate.length} arquivos...`);
            
            let errors = 0;
            for (const file of toUpdate) {
                const success = await writeToFile(file);
                if (!success) errors++;
            }
            
            if (errors > 0) {
                log(`Finalizado com ${errors} erros.`);
                await showAlert(`${errors} arquivos falharam ao salvar. Verifique se estão abertos em outro programa.`, "Atenção");
            } else {
                log("Sincronização concluída com sucesso!");
                await showAlert("Todos os arquivos foram sincronizados.", "Sucesso");
            }
            renderTable();
        }

        async function getOrCreateFileHandle(root, path) {
            const parts = path.split('/');
            parts.shift(); // Remove pasta raiz
            
            const fileName = parts.pop();
            let currentDir = root;

            for (const dirName of parts) {
                currentDir = await currentDir.getDirectoryHandle(dirName, { create: true });
            }

            return await currentDir.getFileHandle(fileName, { create: true });
        }

        async function writeToFile(fileObj) {
            try {
                if (!fileObj.handle) {
                    fileObj.handle = await getOrCreateFileHandle(rootDirectoryHandle, fileObj.localPath);
                    fileObj.isMissingLocally = false;
                }

                const writable = await fileObj.handle.createWritable();
                await writable.write(fileObj.remoteBlob);
                await writable.close();

                fileObj.status = 'updated';
                fileObj.localDate = new Date(); 
                updateRowStatus(fileObj);
                return true;
            } catch (error) {
                console.error("Write error:", error);
                fileObj.status = 'write-error';
                updateRowStatus(fileObj);
                return false;
            }
        }

        // --- UI Utils ---
        async function downloadAllAsZip() {
            const validFiles = filesData.filter(f => f.remoteBlob !== null);
            if (validFiles.length === 0) { 
                await showAlert("Sem arquivos baixados para gerar o ZIP.", "Aviso"); 
                return; 
            }

            log("Compactando ZIP...");
            btnDownloadZip.disabled = true;
            try {
                const zip = new JSZip();
                validFiles.forEach(file => {
                    const zipPath = file.localPath.split('/').slice(1).join('/'); 
                    zip.file(zipPath, file.remoteBlob);
                });
                const content = await zip.generateAsync({type: "blob"});
                saveAs(content, `backup_${rootDirectoryHandle.name}.zip`);
                log("ZIP baixado.");
                
            } catch (e) { 
                await showAlert("Erro ao gerar ZIP: " + e.message, "Erro");
            } finally {
                btnDownloadZip.disabled = false;
            }
        }

        function log(msg) { logStatusSpan.innerText = msg; }
        
        function formatDate(date) {
            if (!date) return '--';
            return date.toLocaleString('pt-BR', { 
                day: '2-digit', month: '2-digit', year: '2-digit', 
                hour: '2-digit', minute: '2-digit'
            });
        }

        function renderTableLoading(msg) {
            fileListBody.innerHTML = `<tr><td colspan="5" class="p-8 text-center text-blue-400"><i class="fas fa-spinner fa-2x"></i><br>${msg}</td></tr>`;
        }

        function renderTable() {
            fileListBody.innerHTML = '';
            if (filesData.length === 0) {
                fileListBody.innerHTML = `<tr><td colspan="5" class="p-8 text-center text-gray-500">Lista vazia.</td></tr>`;
                return;
            }
            filesData.forEach(file => {
                const tr = document.createElement('tr');
                tr.id = `row-${file.id}`;
                tr.className = "hover:bg-gray-800/50 transition-colors border-b border-gray-700/50";
                tr.innerHTML = getRowHTML(file);
                fileListBody.appendChild(tr);
            });
        }

        function updateRowStatus(file) {
            const row = document.getElementById(`row-${file.id}`);
            if (row) row.innerHTML = getRowHTML(file);
        }

        function getRowHTML(file) {
            let statusBadge = '<span class="text-gray-600">-</span>';
            let actionBtn = '';
            let rowClass = '';
            
            switch (file.status) {
                case 'checking':
                    statusBadge = '<i class="fas fa-spinner text-blue-400"></i>';
                    break;
                case 'current':
                    statusBadge = '<span class="status-updated text-xs font-bold uppercase"><i class="fa-solid fa-check"></i> Sincronizado</span>';
                    actionBtn = '<span class="text-gray-600 text-xs">OK</span>';
                    break;
                case 'outdated':
                    statusBadge = '<span class="status-outdated text-xs font-bold uppercase"><i class="fa-solid fa-clock"></i> Desatualizado</span>';
                    actionBtn = `<button onclick="triggerSingleUpdate('${file.id}')" class="bg-yellow-600 hover:bg-yellow-500 text-white px-3 py-1 rounded text-xs shadow">Atualizar</button>`;
                    break;
                case 'missing':
                    statusBadge = '<span class="status-missing text-xs font-bold uppercase"><i class="fa-solid fa-plus-circle"></i> Novo / Faltando</span>';
                    actionBtn = `<button onclick="triggerSingleUpdate('${file.id}')" class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-xs shadow">Baixar</button>`;
                    break;
                case 'untracked':
                    statusBadge = '<span class="status-untracked text-xs font-bold uppercase"><i class="fa-solid fa-question-circle"></i> Apenas Local</span>';
                    rowClass = 'opacity-60';
                    break;
                case 'updated':
                    statusBadge = '<span class="text-blue-400 text-xs font-bold uppercase">Sucesso</span>';
                    actionBtn = '<span class="text-blue-500 text-xs"><i class="fa-solid fa-check-double"></i> Feito</span>';
                    break;
                case 'error':
                    statusBadge = `<span class="status-error text-xs font-bold">ERRO ${file.httpStatus || ''}</span>`;
                    break;
                case 'write-error':
                    statusBadge = '<span class="text-red-500 text-xs font-bold">Erro Disco</span>';
                    break;
            }

            const remoteDateClass = (file.remoteDate && file.localDate && file.remoteDate > file.localDate) ? "text-yellow-400 font-bold" : "text-gray-400";
            const displayName = file.localPath.split('/').pop();
            const displayPath = file.localPath;

            return `
                <td class="p-4 font-mono text-gray-300 break-all text-xs ${rowClass}">
                    <div class="font-bold text-sm ${file.status === 'missing' ? 'text-purple-400' : ''}">${displayName}</div>
                    <div class="text-gray-500">${displayPath}</div>
                </td>
                <td class="p-4 text-xs text-gray-400 font-mono ${rowClass}">${formatDate(file.localDate)}</td>
                <td class="p-4 text-xs ${remoteDateClass} font-mono ${rowClass}">${formatDate(file.remoteDate)}</td>
                <td class="p-4 text-center ${rowClass}">${statusBadge}</td>
                <td class="p-4 text-center ${rowClass}">${actionBtn}</td>
            `;
        }

        window.triggerSingleUpdate = async (id) => {
            const file = filesData.find(f => f.id === id);
            if (!file) return;

            // Usa o modal customizado com await
            const confirmMsg = file.status === 'missing' 
                ? `Deseja baixar o novo arquivo:\n${file.localPath}?` 
                : `Deseja sobrescrever o arquivo local:\n${file.localPath}?`;

            const confirmed = await showModal({
                title: "Confirmar Ação",
                message: confirmMsg,
                type: 'danger', // Estilo vermelho para alertar sobre escrita
                confirmText: "Sim, Executar"
            });

            if (confirmed) {
                await writeToFile(file);
            }
        };
    </script>
</body>
</html>