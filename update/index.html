<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sincronizador Inteligente - Comparação por Data</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Biblioteca para criar ZIPs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Biblioteca FileSaver para garantir compatibilidade de download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .fa-spinner { animation: spin 1s linear infinite; }
        
        /* Cores de Status */
        .status-updated { color: #10b981; } /* Verde - Local é atual */
        .status-outdated { color: #f59e0b; } /* Laranja - Local é velho */
        .status-error { color: #ef4444; }   /* Vermelho - Erro */

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen p-6">

    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="mb-8 border-b border-gray-700 pb-4">
            <h1 class="text-3xl font-bold text-blue-400 mb-2">
                <i class="fa-solid fa-sync mr-2"></i> Sincronizador Inteligente R2
            </h1>
            <p class="text-gray-400">
                Compara datas de modificação e atualiza apenas o necessário.
                <br>
                Base: <code class="bg-gray-800 px-2 py-1 rounded text-yellow-500 text-sm">https://extensions.io.log.br/renovaweb/...</code>
            </p>
        </header>

        <!-- Controles -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-6 border border-gray-700">
            <div class="flex flex-col md:flex-row gap-4 items-center justify-between">
                
                <div class="flex-1 w-full space-y-2">
                    <!-- Botão Padrão -->
                    <button id="btnSelectDir" class="w-full md:w-auto bg-blue-600 hover:bg-blue-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <i class="fa-solid fa-folder-open"></i> Selecionar Pasta Local
                    </button>
                    
                    <!-- Botão de Restaurar (Oculto por padrão) -->
                    <button id="btnRestoreDir" class="hidden w-full md:w-auto bg-purple-600 hover:bg-purple-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors items-center justify-center gap-2">
                        <i class="fa-solid fa-folder-tree"></i> Restaurar Acesso à Pasta Anterior
                    </button>

                    <p id="selectedPathDisplay" class="text-sm text-gray-400 italic">Nenhum diretório selecionado</p>
                </div>

                <div class="flex flex-wrap gap-3 justify-end">
                    <button id="btnCheckAll" disabled class="disabled:opacity-50 disabled:cursor-not-allowed bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded border border-gray-600">
                        <i class="fa-solid fa-magnifying-glass"></i> Comparar Datas
                    </button>
                    
                    <button id="btnUpdateAll" disabled class="disabled:opacity-50 disabled:cursor-not-allowed bg-yellow-600 hover:bg-yellow-500 text-white py-2 px-4 rounded border border-yellow-600 shadow-lg shadow-yellow-900/50 font-bold">
                        <i class="fa-solid fa-download"></i> Atualizar Desatualizados
                    </button>

                    <button id="btnDownloadZip" disabled class="disabled:opacity-50 disabled:cursor-not-allowed bg-green-700 hover:bg-green-600 text-white py-2 px-4 rounded border border-green-600 shadow-lg shadow-green-900/50">
                        <i class="fa-solid fa-file-zipper"></i> Baixar ZIP
                    </button>
                </div>
            </div>
        </div>

        <!-- Tabela de Arquivos -->
        <div class="bg-gray-800 rounded-lg shadow-lg overflow-hidden border border-gray-700">
            <div class="overflow-x-auto">
                <table class="w-full text-left border-collapse text-sm">
                    <thead>
                        <tr class="bg-gray-900 text-gray-400 uppercase tracking-wider">
                            <th class="p-4 border-b border-gray-700">Arquivo</th>
                            <th class="p-4 border-b border-gray-700 w-48">Data Local</th>
                            <th class="p-4 border-b border-gray-700 w-48">Data Nuvem</th>
                            <th class="p-4 border-b border-gray-700 w-32 text-center">Status</th>
                            <th class="p-4 border-b border-gray-700 w-32 text-center">Ação</th>
                        </tr>
                    </thead>
                    <tbody id="fileListBody" class="divide-y divide-gray-700">
                        <tr>
                            <td colspan="5" class="p-8 text-center text-gray-500">
                                Selecione um diretório para iniciar.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- Footer -->
            <div class="p-4 bg-gray-900 border-t border-gray-700 text-xs text-gray-500 flex justify-between">
                <span id="fileCount">0 arquivos</span>
                <span id="logStatus">Aguardando...</span>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        const BASE_URL = "https://extensions.io.log.br/renovaweb/";
        
        let rootDirectoryHandle = null;
        let filesData = [];

        // DOM Elements
        const btnSelectDir = document.getElementById('btnSelectDir');
        const btnRestoreDir = document.getElementById('btnRestoreDir');
        const btnCheckAll = document.getElementById('btnCheckAll');
        const btnUpdateAll = document.getElementById('btnUpdateAll');
        const btnDownloadZip = document.getElementById('btnDownloadZip');
        const fileListBody = document.getElementById('fileListBody');
        const selectedPathDisplay = document.getElementById('selectedPathDisplay');
        const fileCountSpan = document.getElementById('fileCount');
        const logStatusSpan = document.getElementById('logStatus');

        // Events
        btnSelectDir.addEventListener('click', handleDirectorySelection);
        btnRestoreDir.addEventListener('click', restoreDirectoryAccess);
        btnCheckAll.addEventListener('click', checkAllRemoteFiles);
        btnUpdateAll.addEventListener('click', updateOutdatedFiles);
        btnDownloadZip.addEventListener('click', downloadAllAsZip);

        // --- IndexedDB Logic (Para salvar o Handle) ---
        const DB_NAME = 'R2SyncDB';
        const STORE_NAME = 'handles';

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e.target.error);
            });
        }

        async function saveHandle(handle) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            // Salvamos com a chave 'root' pois só precisamos de uma pasta ativa por vez
            tx.objectStore(STORE_NAME).put(handle, 'root'); 
        }

        async function getSavedHandle() {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const request = tx.objectStore(STORE_NAME).get('root');
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Verifica ao carregar se há algo salvo
        window.addEventListener('load', async () => {
            try {
                const saved = await getSavedHandle();
                if (saved) {
                    // Mostra botão de restaurar
                    btnSelectDir.classList.add('hidden');
                    btnRestoreDir.classList.remove('hidden');
                    selectedPathDisplay.textContent = `Pasta Salva: /${saved.name} (Requer confirmação)`;
                    rootDirectoryHandle = saved;
                }
            } catch (e) {
                console.error("Erro ao ler DB", e);
            }
        });

        // --- Core Functions ---

        async function handleDirectorySelection() {
            try {
                rootDirectoryHandle = await window.showDirectoryPicker();
                await saveHandle(rootDirectoryHandle); // Salva no DB
                await initializeDirectoryView();
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error(err);
                    alert("Erro: " + err.message);
                }
            }
        }

        async function restoreDirectoryAccess() {
            if (!rootDirectoryHandle) return;
            
            // Navegadores exigem verificação de permissão ao restaurar handles
            const options = { mode: 'readwrite' };
            if ((await rootDirectoryHandle.queryPermission(options)) !== 'granted') {
                if ((await rootDirectoryHandle.requestPermission(options)) !== 'granted') {
                    alert('Permissão necessária para acessar a pasta salva.');
                    return;
                }
            }
            
            await initializeDirectoryView();
        }

        async function initializeDirectoryView() {
            // Ajusta botões
            btnSelectDir.classList.remove('hidden');
            btnRestoreDir.classList.add('hidden');
            
            selectedPathDisplay.textContent = `Pasta Raiz: /${rootDirectoryHandle.name}`;
            selectedPathDisplay.classList.add('text-green-400');
            selectedPathDisplay.classList.remove('text-gray-400');

            log("Mapeando arquivos locais...");
            filesData = [];
            renderTableLoading();

            await scanDirectoryRecursive(rootDirectoryHandle, rootDirectoryHandle.name);

            renderTable();
            
            btnCheckAll.disabled = false;
            btnUpdateAll.disabled = true;
            btnDownloadZip.disabled = true;
            
            log(`Mapeamento concluído. ${filesData.length} arquivos encontrados.`);
            fileCountSpan.textContent = `${filesData.length} arquivos locais`;
        }


        async function scanDirectoryRecursive(dirHandle, currentPath) {
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file') {
                    const fileObj = await entry.getFile();
                    const fullPath = `${currentPath}/${entry.name}`;
                    const remoteUrl = `${BASE_URL}${fullPath}`;

                    filesData.push({
                        id: crypto.randomUUID(),
                        localPath: fullPath,
                        handle: entry,
                        remoteUrl: remoteUrl,
                        status: 'pending',
                        localDate: new Date(fileObj.lastModified),
                        remoteDate: null,
                        remoteBlob: null,
                        httpStatus: null
                    });
                } else if (entry.kind === 'directory') {
                    await scanDirectoryRecursive(entry, `${currentPath}/${entry.name}`);
                }
            }
        }

        async function checkAllRemoteFiles() {
            btnCheckAll.disabled = true;
            btnUpdateAll.disabled = true;
            btnDownloadZip.disabled = true;
            log("Comparando datas e baixando metadados...");

            const promises = filesData.map(file => checkSingleFile(file));
            await Promise.all(promises);

            renderTable();
            
            const hasOutdated = filesData.some(f => f.status === 'outdated');
            
            // Verifica se tem arquivos baixados com sucesso para o ZIP
            const hasDownloads = filesData.some(f => f.remoteBlob !== null);

            if (hasOutdated) {
                btnUpdateAll.disabled = false;
                const count = filesData.filter(f => f.status === 'outdated').length;
                log(`Verificação: ${count} arquivo(s) desatualizado(s).`);
            } else {
                log("Verificação concluída.");
            }

            if (hasDownloads) {
                btnDownloadZip.disabled = false;
            }

            btnCheckAll.disabled = false;
        }

        async function checkSingleFile(fileObj) {
            fileObj.status = 'checking';
            updateRowStatus(fileObj);

            try {
                const response = await fetch(fileObj.remoteUrl, { 
                    method: 'GET',
                    cache: 'no-cache' 
                });

                fileObj.httpStatus = response.status;

                if (response.ok) {
                    fileObj.remoteBlob = await response.blob();
                    
                    const lastModifiedHeader = response.headers.get('Last-Modified');
                    
                    if (lastModifiedHeader) {
                        fileObj.remoteDate = new Date(lastModifiedHeader);
                        if (fileObj.remoteDate > fileObj.localDate) {
                            fileObj.status = 'outdated';
                        } else {
                            fileObj.status = 'current';
                        }
                    } else {
                        fileObj.status = 'outdated'; 
                    }

                } else {
                    fileObj.status = 'error';
                    fileObj.remoteBlob = null;
                }

            } catch (error) {
                console.warn(`Erro fetch ${fileObj.remoteUrl}:`, error);
                fileObj.status = 'error';
                fileObj.httpStatus = 'NET';
            }
            updateRowStatus(fileObj);
        }

        // --- Função ZIP ---
        async function downloadAllAsZip() {
            const validFiles = filesData.filter(f => f.remoteBlob !== null);
            
            if (validFiles.length === 0) {
                alert("Nenhum arquivo válido foi baixado da nuvem para criar o ZIP.");
                return;
            }

            log("Gerando arquivo ZIP...");
            btnDownloadZip.disabled = true;

            try {
                const zip = new JSZip();

                // Adiciona arquivos ao ZIP mantendo a estrutura
                validFiles.forEach(file => {
                    // file.localPath é algo como "PastaRaiz/sub/arquivo.css"
                    // Vamos remover a pasta raiz do nome para o ZIP ficar limpo, ou manter.
                    // Opção: Manter o caminho completo
                    zip.file(file.localPath, file.remoteBlob);
                });

                // Gera o binário
                const content = await zip.generateAsync({type: "blob"});
                
                // Salva
                const zipName = `backup_${rootDirectoryHandle.name}_${new Date().toISOString().slice(0,10)}.zip`;
                saveAs(content, zipName);
                
                log("ZIP gerado com sucesso!");
            } catch (e) {
                console.error(e);
                alert("Erro ao gerar ZIP: " + e.message);
                log("Erro na geração do ZIP.");
            } finally {
                btnDownloadZip.disabled = false;
            }
        }

        async function updateOutdatedFiles() {
            const toUpdate = filesData.filter(f => f.status === 'outdated');
            if (toUpdate.length === 0) return;
            
            if(!confirm(`Deseja atualizar ${toUpdate.length} arquivos locais?`)) {
                return;
            }

            log(`Atualizando ${toUpdate.length} arquivos...`);
            for (const file of toUpdate) {
                await writeToFile(file);
            }
            log("Sincronização concluída!");
            renderTable();
        }

        async function writeToFile(fileObj) {
            try {
                const writable = await fileObj.handle.createWritable();
                await writable.write(fileObj.remoteBlob);
                await writable.close();

                fileObj.status = 'updated';
                fileObj.localDate = new Date(); 
                updateRowStatus(fileObj);
            } catch (error) {
                console.error("Write error:", error);
                fileObj.status = 'write-error';
                updateRowStatus(fileObj);
            }
        }

        // --- Renderização e Auxiliares ---

        function log(msg) { logStatusSpan.innerText = msg; }

        function formatDate(date) {
            if (!date) return '--';
            return date.toLocaleString('pt-BR', { 
                day: '2-digit', month: '2-digit', year: '2-digit', 
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
        }

        function renderTableLoading() {
            fileListBody.innerHTML = `<tr><td colspan="5" class="p-8 text-center text-blue-400"><i class="fas fa-spinner fa-2x"></i><br>Lendo disco...</td></tr>`;
        }

        function renderTable() {
            fileListBody.innerHTML = '';
            if (filesData.length === 0) {
                fileListBody.innerHTML = `<tr><td colspan="5" class="p-8 text-center text-gray-500">Pasta vazia.</td></tr>`;
                return;
            }
            filesData.forEach(file => {
                const tr = document.createElement('tr');
                tr.id = `row-${file.id}`;
                tr.className = "hover:bg-gray-800/50 transition-colors border-b border-gray-700/50";
                tr.innerHTML = getRowHTML(file);
                fileListBody.appendChild(tr);
            });
        }

        function updateRowStatus(file) {
            const row = document.getElementById(`row-${file.id}`);
            if (row) row.innerHTML = getRowHTML(file);
        }

        function getRowHTML(file) {
            let statusBadge = '<span class="text-gray-600">-</span>';
            let actionBtn = '';
            
            switch (file.status) {
                case 'checking':
                    statusBadge = '<i class="fas fa-spinner text-blue-400"></i>';
                    break;
                case 'current':
                    statusBadge = '<span class="status-updated text-xs font-bold uppercase"><i class="fa-solid fa-check"></i> Recente</span>';
                    actionBtn = '<span class="text-gray-600 text-xs">Atualizado</span>';
                    break;
                case 'outdated':
                    statusBadge = '<span class="status-outdated text-xs font-bold uppercase"><i class="fa-solid fa-clock"></i> Antigo</span>';
                    actionBtn = `<button onclick="triggerSingleUpdate('${file.id}')" class="bg-yellow-600 hover:bg-yellow-500 text-white px-3 py-1 rounded text-xs transition-colors shadow">Atualizar</button>`;
                    break;
                case 'updated':
                    statusBadge = '<span class="text-blue-400 text-xs font-bold uppercase">Sucesso</span>';
                    actionBtn = '<span class="text-blue-500 text-xs"><i class="fa-solid fa-check-double"></i> Feito</span>';
                    break;
                case 'error':
                    statusBadge = `<span class="status-error text-xs font-bold">ERRO ${file.httpStatus || ''}</span>`;
                    break;
                case 'write-error':
                    statusBadge = '<span class="text-red-500 text-xs font-bold">Erro Disco</span>';
                    break;
            }

            const remoteDateClass = (file.remoteDate > file.localDate) ? "text-yellow-400 font-bold" : "text-gray-400";

            return `
                <td class="p-4 font-mono text-gray-300 break-all text-xs">
                    <div class="font-bold text-sm">${file.localPath.split('/').pop()}</div>
                    <div class="text-gray-500">${file.localPath}</div>
                </td>
                <td class="p-4 text-xs text-gray-400 font-mono">${formatDate(file.localDate)}</td>
                <td class="p-4 text-xs ${remoteDateClass} font-mono">${formatDate(file.remoteDate)}</td>
                <td class="p-4 text-center">${statusBadge}</td>
                <td class="p-4 text-center">${actionBtn}</td>
            `;
        }

        window.triggerSingleUpdate = async (id) => {
            const file = filesData.find(f => f.id === id);
            if (file) await writeToFile(file);
        };
    </script>
</body>
</html>