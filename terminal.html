<!DOCTYPE html>
<html lang="pt-br" class="bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal ASCII VT-100</title>
    <!-- 1. Carrega o TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Força o layout de tela cheia sem rolagem */
        html, body {
            overflow: hidden;
            background-color: #05050a; 
        }

        /* Canvas agora preenche a tela inteira */
        canvas#terminalCanvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
            cursor: text;
            width: 100vw;
            height: 100vh;
        }

        /* Input "fantasma" para teclado móvel */
        #hiddenInput {
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">

    <!-- 
      O container do modal agora permite rolagem vertical (overflow-y-auto)
    -->
    <div id="configModal" class="hidden fixed inset-0 z-50 overflow-y-auto bg-black bg-opacity-70 p-4 py-10">
        <!-- 
          Conteúdo do Modal 
        -->
        <div id="configModalContent" class="bg-gray-800 p-6 rounded-lg shadow-xl grid grid-cols-1 md:grid-cols-3 gap-4 w-full max-w-6xl relative mx-auto">
            
            <!-- Botão Fechar -->
            <button id="closeModal" class="absolute top-2 right-3 text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
            
            <h2 class="col-span-1 md:col-span-3 text-2xl font-bold text-emerald-400 mb-2">Configurações do Terminal</h2>

            <!-- Card 1: Dimensões -->
            <div class="flex flex-col space-y-2 p-4 bg-gray-700 rounded-md">
                <h3 class="text-lg font-semibold text-gray-200">Dimensões</h3>
                <div class="flex items-center space-x-2">
                    <label for="rowsInput" class="text-sm font-medium text-gray-300">Linhas:</label>
                    <input type="number" id="rowsInput" value="25" class="w-20 bg-gray-900 text-white p-2 rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="colsInput" class="text-sm font-medium text-gray-300">Colunas:</label>
                    <input type="number" id="colsInput" value="80" class="w-20 bg-gray-900 text-white p-2 rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                </div>
                <button id="applySettings" class="mt-2 bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200">
                    Aplicar e Fechar
                </button>
            </div>
            
            <!-- Card 2: Personalização -->
            <div class="flex flex-col space-y-4 p-4 bg-gray-700 rounded-md">
                <h3 class="text-lg font-semibold text-gray-200">Personalização</h3>
                <div>
                    <label for="fontFile" class="block text-sm font-medium text-gray-300 mb-1">Carregar Fonte (.json):</label>
                    <input type="file" id="fontFile" accept=".json" class="text-sm text-gray-400 file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-emerald-600 file:text-white hover:file:bg-emerald-700">
                </div>
                <div>
                    <label for="colorFile" class="block text-sm font-medium text-gray-300 mb-1">Carregar Cores (.json):</label>
                    <input type="file" id="colorFile" accept=".json" class="text-sm text-gray-400 file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                </div>
            </div>

            <!-- Card 3: Informações de Formato -->
            <div class="text-xs text-gray-400 bg-gray-900 p-4 rounded-md border border-gray-700">
                <h3 class="text-lg font-semibold text-gray-200 mb-2">Formatos JSON</h3>
                <p class="font-bold">Formato da Fonte:</p>
                <pre class="whitespace-pre-wrap">{
  "charWidth": 8, "charHeight": 8,
  "data": { "A": ["010", ...], ... }
}</pre>
                <p class="font-bold mt-2">Formato das Cores:</p>
                <pre>{ "bg": "#000", "fg": "#0f0", "cursor": "#fff" }</pre>
            </div>
        </div>
    </div>

    <!-- O Canvas do Terminal agora é o elemento principal -->
    <div class="w-full flex justify-center">
        <canvas id="terminalCanvas" class="bg-black" tabindex="0">
            Seu navegador não suporta o elemento canvas.
        </canvas>
    </div>

    <!-- Input "Fantasma" para Teclado Móvel -->
    <input 
        type="text" 
        id="hiddenInput" 
        autocapitalize="off" 
        autocorrect="off" 
        spellcheck="false" 
        autocomplete="off"
    >

    <!-- 5. Lógica do Terminal em JavaScript -->
    <script>
        // --- Variáveis Globais ---
        let canvas, ctx, hiddenInput;
        let configModal, closeModal, applySettingsBtn, fontFile, colorFile, rowsInput, colsInput;
        
        let rows = 25, cols = 80;
        let cursor = { x: 0, y: 0 };
        let cursorBlinkState = true;
        
        let screenData = [];
        
        let currentInputLine = "";
        let promptX = 0; 

        // Cores padrão que podem ser sobrescritas pelo localStorage
        let colors = {
            bg: "#05050a",     
            fg: "#34d399",     
            cursor: "#ffffff"  
        };

        // --- Fonte Padrão (será sobrescrita pelo localStorage se existir) ---
        // O OBJETO JSON GIGANTE FOI REMOVIDO DAQUI
        let fontSet; // Agora é indefinido por padrão

        // --- Chaves do LocalStorage ---
        const STORAGE_KEYS = {
            DIMENSIONS: 'terminalDimensions',
            COLORS: 'terminalColors',
            FONT: 'terminalFont'
        };

        // --- Inicialização ---
        window.onload = async () => { // <-- TORNADO ASYNC
            // Elementos do Terminal
            canvas = document.getElementById('terminalCanvas');
            ctx = canvas.getContext('2d');
            hiddenInput = document.getElementById('hiddenInput');
            
            ctx.imageSmoothingEnabled = false;

            // Elementos do Modal
            configModal = document.getElementById('configModal');
            closeModal = document.getElementById('closeModal');
            applySettingsBtn = document.getElementById('applySettings');
            fontFile = document.getElementById('fontFile');
            colorFile = document.getElementById('colorFile');
            rowsInput = document.getElementById('rowsInput');
            colsInput = document.getElementById('colsInput');

            // Listeners
            applySettingsBtn.addEventListener('click', applySettings);
            closeModal.addEventListener('click', hideConfigModal);
            fontFile.addEventListener('change', loadFont);
            colorFile.addEventListener('change', loadColors);

            hiddenInput.addEventListener('input', handleInput); 
            hiddenInput.addEventListener('keydown', handleControlKeys); 
            
            canvas.addEventListener('click', () => hiddenInput.focus());
            canvas.addEventListener('focus', () => hiddenInput.focus());
            
            hiddenInput.focus();
            
            // Carrega configurações salvas ou usa padrões
            await loadSettingsFromStorage(); // <-- ADICIONADO AWAIT
            
            // Atualiza os inputs do modal para refletir os valores carregados
            rowsInput.value = rows;
            colsInput.value = cols;

            initializeTerminal();

            setInterval(toggleCursor, 500);
        };

        // --- Funções de Armazenamento ---

        async function loadSettingsFromStorage() { // <-- TORNADO ASYNC
            try {
                // Carregar Dimensões
                const storedDims = localStorage.getItem(STORAGE_KEYS.DIMENSIONS);
                if (storedDims) {
                    const dims = JSON.parse(storedDims);
                    rows = dims.rows || 25;
                    cols = dims.cols || 80;
                }

                // Carregar Cores
                const storedColors = localStorage.getItem(STORAGE_KEYS.COLORS);
                if (storedColors) {
                    colors = JSON.parse(storedColors);
                }

                // Carregar Fonte
                const storedFont = localStorage.getItem(STORAGE_KEYS.FONT);
                if (storedFont) {
                    fontSet = JSON.parse(storedFont);
                } else {
                    // Se não houver fonte no localStorage, busca a defaultFont.json
                    const response = await fetch('defaultFont.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    fontSet = await response.json();
                }

            } catch (e) {
                console.error("Erro ao carregar configurações do localStorage ou defaultFont.json:", e);
                // Fallback de emergência para evitar que o app quebre
                fontSet = {
                    charWidth: 8,
                    charHeight: 8,
                    data: {
                        " ": [ "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000" ],
                        "?": [ "00111100", "01000010", "01000010", "00000100", "00011000", "00000000", "00011000", "00000000" ]
                    }
                };
                colors = { bg: "#05050a", fg: "#FF0000", cursor: "#ffffff" }; // Cor de erro
                rows = 25;
                cols = 80;
            }
        }

        // --- Funções Principais ---

        function initializeTerminal() {
            canvas.width = cols * fontSet.charWidth;
            canvas.height = rows * fontSet.charHeight;
            
            screenData = [];
            for (let y = 0; y < rows; y++) {
                screenData.push(createBlankRow(cols));
            }
            
            cursor = { x: 0, y: 0 };
            drawScreen();
            
            typeString("Bem-vindo ao Terminal ASCII!\n");
            typeString("Configuracoes carregadas do localStorage.\n");
            typeString("Digite 'config' para abrir as configuracoes.\n");
            typeString("> ");
            promptX = cursor.x; 
        }

        function createBlankRow(width) {
            const row = [];
            for (let x = 0; x < width; x++) {
                row.push({ char: ' ', fg: colors.fg, bg: colors.bg });
            }
            return row;
        }

        function drawScreen() {
            if (!ctx) return;

            // Define a cor de fundo com base nas cores carregadas
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const cell = screenData[y][x];
                    // Redesenha a célula se ela for diferente do "vazio" padrão
                    if (cell.char !== ' ' || cell.bg !== colors.bg || cell.fg !== colors.fg) {
                         drawChar(cell.char, x, y, cell.fg, cell.bg);
                    }
                }
            }

            // Desenha o cursor
            if (document.activeElement === hiddenInput && cursorBlinkState) {
                const cellUnderCursor = (screenData[cursor.y] && screenData[cursor.y][cursor.x])
                    ? screenData[cursor.y][cursor.x]
                    : { char: ' ', fg: colors.fg, bg: colors.bg }; 
                
                drawChar(
                    cellUnderCursor.char, 
                    cursor.x, 
                    cursor.y, 
                    colors.bg,      // Inverte fg/bg para o cursor
                    colors.cursor   // Usa a cor do cursor
                );
            }
        }

        function drawChar(char, gridX, gridY, fg, bg) {
            if (gridX >= cols || gridY >= rows || gridX < 0 || gridY < 0) return;

            const px = gridX * fontSet.charWidth;
            const py = gridY * fontSet.charHeight;
            
            ctx.fillStyle = bg;
            ctx.fillRect(px, py, fontSet.charWidth, fontSet.charHeight);

            // Busca o caractere na fonte; se não encontrar, usa '?'
            const charBitmap = fontSet.data[char] || fontSet.data['?'];
            
            if (!charBitmap) return; // Se nem '?' existir, não desenha

            ctx.fillStyle = fg;
            
            for (let y = 0; y < fontSet.charHeight; y++) {
                const row = charBitmap[y] || "";
                for (let x = 0; x < fontSet.charWidth; x++) {
                    if (row[x] === '1') {
                        ctx.fillRect(px + x, py + y, 1, 1);
                    }
                }
            }
        }

        // --- Lógica do Terminal ---

        function handleInput(e) {
            const text = e.target.value;
            if (text) {
                typeString(text);
                currentInputLine += text; 
                drawScreen();
            }
            e.target.value = '';
        }

        function handleControlKeys(e) {
            const key = e.key;
            let dirty = false; // "dirty" significa que a tela precisa ser redesenhada

            if (key === 'Enter') {
                e.preventDefault();
                processCommand(currentInputLine); 
                currentInputLine = ""; 
                newLine(); 
                typeString("> "); 
                promptX = cursor.x; 
                dirty = true;
            } else if (key === 'Backspace') {
                e.preventDefault();
                backspace(); 
                dirty = true;
            }

            if (dirty) {
                cursorBlinkState = true; // Força o cursor a aparecer
                drawScreen();
            }
        }

        function typeString(str) {
            for (const char of str) {
                if (char === '\n') {
                    newLine();
                } else {
                    typeChar(char);
                }
            }
        }

        function typeChar(char) {
            if (cursor.x >= cols) {
                cursor.x = 0;
                cursor.y++;
                checkScroll();
            }

            if (cursor.y >= rows) {
                return; // Evita escrever fora da tela (embora o scroll deva cuidar disso)
            }

            screenData[cursor.y][cursor.x] = { char, fg: colors.fg, bg: colors.bg };
            cursor.x++;
            
            // Quebra de linha automática (wrap)
            if (cursor.x >= cols) {
                cursor.x = 0;
                cursor.y++;
                checkScroll();
            }
        }

        function newLine() {
            cursor.y++;
            cursor.x = 0;
            checkScroll();
        }

        function backspace() {
            // Só permite apagar se o cursor estiver depois do prompt
            if (cursor.x > promptX) {
                cursor.x--;
                screenData[cursor.y][cursor.x] = { char: ' ', fg: colors.fg, bg: colors.bg };
                currentInputLine = currentInputLine.slice(0, -1); 
            }
        }

        function checkScroll() {
            // Se o cursor passou da última linha
            if (cursor.y >= rows) {
                screenData.shift(); // Remove a linha do topo
                screenData.push(createBlankRow(cols)); // Adiciona uma linha em branco embaixo
                cursor.y = rows - 1; // Move o cursor para a última linha
            }
        }

        function toggleCursor() {
            cursorBlinkState = !cursorBlinkState;
            drawScreen();
        }

        // --- Funções do Modal e Comandos ---

        function showConfigModal() {
            rowsInput.value = rows;
            colsInput.value = cols;
            configModal.classList.remove('hidden');
        }

        function hideConfigModal() {
            configModal.classList.add('hidden');
            hiddenInput.focus(); // Devolve o foco ao terminal
        }

        function processCommand(command) {
            const cmd = command.trim().toUpperCase();
            
            if (cmd === 'CONFIG') {
                showConfigModal();
            }
        }

        // --- Funções de Configuração ---
        function applySettings() {
            rows = parseInt(rowsInput.value);
            cols = parseInt(colsInput.value);

            // Salva dimensões no localStorage
            try {
                localStorage.setItem(STORAGE_KEYS.DIMENSIONS, JSON.stringify({ rows, cols }));
            } catch (e) {
                console.error("Erro ao salvar dimensões:", e);
            }

            initializeTerminal(); 
            hideConfigModal(); 
        }

        function loadFont(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonString = e.target.result;
                    const newFont = JSON.parse(jsonString);
                    
                    if (newFont.charWidth && newFont.charHeight && newFont.data) {
                        fontSet = newFont;
                        console.log("Fonte personalizada carregada:", fontSet);
                        // Salva fonte no localStorage
                        localStorage.setItem(STORAGE_KEYS.FONT, jsonString);
                        initializeTerminal(); // <-- CORREÇÃO: Aplica a fonte imediatamente
                    } else {
                        console.error("Formato de fonte JSON inválido!");
                    }
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON da fonte: " + err.message);
                }
            };
            reader.readAsText(file);
        }

        function loadColors(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonString = e.target.result;
                    const newColors = JSON.parse(jsonString);
                    
                    colors = { ...colors, ...newColors }; // Mescla cores novas com as existentes
                    
                    console.log("Cores personalizadas carregadas:", colors);
                    // Salva cores no localStorage
                    localStorage.setItem(STORAGE_KEYS.COLORS, JSON.stringify(colors));
                    initializeTerminal(); // <-- CORREÇÃO: Aplica as cores imediatamente
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON de cores: " + err.message);
                }
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>

