<!DOCTYPE html>
<html lang="pt-br" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal VT-100 ASCII</title>
    <!-- Carrega o TailwindCSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Força o visual pixelado/retrô no canvas */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            /* Garante que o canvas não cause "flash" ao focar no input invisível */
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Input invisível para capturar o teclado móvel */
        #hiddenInput {
            position: absolute;
            top: -100px;
            left: -100px;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        /* Estilo para o cursor piscando */
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        .cursor-blink {
            animation: blink 1s step-start infinite;
        }
    </style>
</head>
<body class="font-mono text-gray-200 bg-gray-900 h-full overflow-hidden">

    <!-- O Canvas do Terminal ocupa a tela inteira -->
    <canvas id="terminalCanvas" class="w-screen h-screen bg-black cursor-text"></canvas>

    <!-- Input invisível para teclado móvel -->
    <input type="text" id="hiddenInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

    <!-- Modal de Configuração (Oculto por padrão) -->
    <div id="configModal" class="fixed inset-0 bg-black bg-opacity-80 backdrop-blur-sm overflow-y-auto py-10 hidden">
        
        <!-- Conteúdo do Modal -->
        <div class="relative w-full max-w-6xl mx-auto bg-gray-800 rounded-lg shadow-xl p-6">
            
            <!-- Botão de Fechar -->
            <button id="closeModalButton" class="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl leading-none">&times;</button>

            <h2 class="text-2xl font-bold text-white mb-6">Configurações do Terminal</h2>

            <!-- Grid de Configurações -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">

                <!-- Card: Dimensões -->
                <div class="bg-gray-700 p-5 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4">Dimensões</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="rowsInput" class="block text-sm font-medium text-gray-300">Linhas (Rows)</label>
                            <input type="number" id="rowsInput" value="24" class="mt-1 block w-full bg-gray-800 border-gray-600 text-white rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div>
                            <label for="colsInput" class="block text-sm font-medium text-gray-300">Colunas (Cols)</label>
                            <input type="number" id="colsInput" value="80" class="mt-1 block w-full bg-gray-800 border-gray-600 text-white rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    </div>
                </div>

                <!-- Card: Personalização -->
                <div class="bg-gray-700 p-5 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4">Personalização</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="fontLoader" class="block text-sm font-medium text-gray-300">Carregar Fonte (JSON)</label>
                            <input type="file" id="fontLoader" accept=".json" class="mt-1 block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                        </div>
                        <div>
                            <label for="colorLoader" class="block text-sm font-medium text-gray-300">Carregar Cores (JSON)</label>
                            <input type="file" id="colorLoader" accept=".json" class="mt-1 block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                        </div>
                    </div>
                </div>

                <!-- Card: Formatos JSON -->
                <div class="bg-gray-700 p-5 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4">Formatos JSON Esperados</h3>
                    <p class="text-xs text-gray-400 mb-2">Use o código ASCII decimal como chave.</p>
                    <pre class="bg-gray-800 text-gray-300 p-3 rounded-md text-xs overflow-auto">
{
  "charWidth": 8,
  "charHeight": 8,
  "data": {
    "65": [
      "01111000",
      "..."
    ],
    "66": [ ... ]
  }
}
                    </pre>
                    <pre class="bg-gray-800 text-gray-300 p-3 rounded-md text-xs overflow-auto mt-2">
{
  "fg": "#FFFFFF",
  "bg": "#000000",
  "cursor": "#FFFFFF"
}
                    </pre>
                </div>

            </div>

            <!-- Botão de Aplicar -->
            <div class="mt-8 text-right">
                <button id="applyButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-150">
                    Aplicar e Fechar
                </button>
            </div>
        </div>
    </div>


    <script>
        // --- Elementos DOM ---
        const canvas = document.getElementById('terminalCanvas');
        const ctx = canvas.getContext('2d');
        const hiddenInput = document.getElementById('hiddenInput');
        
        // --- Elementos do Modal ---
        const configModal = document.getElementById('configModal');
        const applyButton = document.getElementById('applyButton');
        const closeModalButton = document.getElementById('closeModalButton');
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const fontLoader = document.getElementById('fontLoader');
        const colorLoader = document.getElementById('colorLoader');

        // --- Estado do Terminal ---
        let terminalRows = 24;
        let terminalCols = 80;
        
        let fontSet = {
            charWidth: 8,
            charHeight: 8,
            data: {}
        };
        
        let colors = {
            fg: '#FFFFFF', // Cor do texto padrão
            bg: '#000000', // Cor de fundo
            cursor: '#FFFFFF' // Cor do cursor
        };

        // Fallback de emergência (se o JSON falhar)
        const emergencyFont = {
            charWidth: 8,
            charHeight: 8,
            data: {
                "32": [ "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000" ],
                "63": [ "00111100", "01000010", "01000010", "00000100", "00011000", "00000000", "00011000", "00000000" ]
            }
        };

        let screenData = []; // Array 2D [linha][coluna] -> { char: 'A', fg: '#FFF', bg: '#000' }
        let cursor = { x: 0, y: 0, visible: true };
        let blinkInterval;
        let isModalOpen = false;

        // --- Estado da Linha de Comando ---
        let currentInputLine = ""; // Rastreia o input atual
        let promptX = 2; // Posição X onde o prompt ('> ') termina

        // --- Inicialização ---

        // Carrega as configurações (ou JSON padrão) e inicia o terminal
        window.onload = async () => {
            try {
                await loadSettingsFromStorage();
            } catch (err) {
                console.error("Falha ao carregar configurações ou fonte padrão:", err);
                fontSet = emergencyFont; // Usa a fonte de emergência
            }
            
            initializeTerminal();

            // Event Listeners Globais
            window.addEventListener('resize', resizeCanvasDisplay);
            canvas.addEventListener('click', focusHiddenInput);
            hiddenInput.addEventListener('keydown', handleKeydown);

            // Listeners do Modal
            applyButton.addEventListener('click', applySettings);
            closeModalButton.addEventListener('click', hideConfigModal);
            fontLoader.addEventListener('change', loadFont);
            colorLoader.addEventListener('change', loadColors);
        };

        // Carrega configurações do localStorage ou busca a fonte padrão
        async function loadSettingsFromStorage() {
            // 1. Carregar Dimensões
            const savedDims = localStorage.getItem('terminalDimensions');
            if (savedDims) {
                const { rows, cols } = JSON.parse(savedDims);
                terminalRows = rows;
                terminalCols = cols;
            }
            rowsInput.value = terminalRows;
            colsInput.value = terminalCols;

            // 2. Carregar Cores
            const savedColors = localStorage.getItem('terminalColors');
            if (savedColors) {
                colors = { ...colors, ...JSON.parse(savedColors) };
            }

            // 3. Carregar Fonte
            const savedFont = localStorage.getItem('terminalFont');
            if (savedFont) {
                fontSet = JSON.parse(savedFont);
                console.log("Fonte carregada do localStorage.");
            } else {
                // Se não houver fonte salva, busca a padrão
                console.log("Buscando defaultFont.json...");
                const response = await fetch('defaultFont.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                fontSet = await response.json();
                console.log("Fonte padrão carregada do arquivo.");
            }
        }
        
        // (Re)Inicia o terminal com as configurações atuais
        function initializeTerminal() {
            // 1. Ajustar tamanho do <canvas> (resolução interna)
            canvas.width = terminalCols * fontSet.charWidth;
            canvas.height = terminalRows * fontSet.charHeight;
            
            // 2. Ajustar tamanho de exibição do <canvas> (CSS)
            resizeCanvasDisplay();

            // 3. Limpar e preencher o buffer da tela
            screenData = [];
            for (let y = 0; y < terminalRows; y++) {
                const row = [];
                for (let x = 0; x < terminalCols; x++) {
                    row.push({ char: ' ', fg: colors.fg, bg: colors.bg });
                }
                screenData.push(row);
            }

            // 4. Resetar cursor e desenhar prompt inicial
            cursor.x = 0;
            cursor.y = 0;
            writePrompt();

            // 5. Iniciar o cursor piscando
            if (blinkInterval) clearInterval(blinkInterval);
            blinkInterval = setInterval(toggleCursor, 500); // Pisca a cada 500ms

            // 6. Desenhar a tela
            drawScreen();
        }

        // --- Lógica de Renderização (Canvas) ---

        // Ajusta o tamanho de exibição (CSS) do canvas para caber na tela
        function resizeCanvasDisplay() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Define o tamanho de exibição do canvas para 100% da tela
            canvas.style.width = `${viewportWidth}px`;
            canvas.style.height = `${viewportHeight}px`;
        }

        // Desenha *toda* a tela com base no `screenData`
        function drawScreen() {
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < terminalRows; y++) {
                for (let x = 0; x < terminalCols; x++) {
                    const cell = screenData[y][x];
                    if (cell.char !== ' ' || cell.bg !== colors.bg) {
                         drawChar(cell.char, x, y, cell.fg, cell.bg);
                    }
                }
            }

            // Desenha o cursor se estiver visível
            if (cursor.visible && !isModalOpen) {
                drawCursor();
            }
        }
        
        // Desenha um único caractere na grade
        function drawChar(char, x, y, fg, bg) {
            const charDataKey = String(char.charCodeAt(0)); // Converte char para código ASCII
            const charData = fontSet.data[charDataKey] || fontSet.data["63"]; // Usa "?" como fallback
            
            if (!charData) return; // Caractere não encontrado

            const startX = x * fontSet.charWidth;
            const startY = y * fontSet.charHeight;

            // Desenha o fundo da célula
            ctx.fillStyle = bg;
            ctx.fillRect(startX, startY, fontSet.charWidth, fontSet.charHeight);

            // Desenha os pixels do caractere
            ctx.fillStyle = fg;
            for (let row = 0; row < fontSet.charHeight; row++) {
                if (!charData[row]) continue;
                for (let col = 0; col < fontSet.charWidth; col++) {
                    if (charData[row][col] === '1') {
                        ctx.fillRect(startX + col, startY + row, 1, 1);
                    }
                }
            }
        }

        // Desenha o cursor na posição atual
        function drawCursor() {
            const x = cursor.x * fontSet.charWidth;
            const y = cursor.y * fontSet.charHeight;
            
            // Adiciona classe de animação para o cursor (se quisermos um bloco piscando)
            // Por simplicidade, vamos usar um sublinhado sólido que pisca via 'toggleCursor'
            
            ctx.fillStyle = colors.cursor;
            ctx.fillRect(x, y + fontSet.charHeight - 2, fontSet.charWidth, 2); // Sublinhado
        }
        
        // Alterna a visibilidade do cursor e redesenha a célula
        function toggleCursor() {
            if (isModalOpen) {
                cursor.visible = false;
                drawScreen(); // Garante que o cursor desapareça quando o modal abrir
                return;
            }

            cursor.visible = !cursor.visible;
            
            // Redesenha apenas a célula do cursor para eficiência
            const cell = screenData[cursor.y][cursor.x];
            drawChar(cell.char, cursor.x, cursor.y, cell.fg, cell.bg);
            if (cursor.visible) {
                drawCursor();
            }
        }

        // --- Lógica de Manipulação do Terminal ---

        // Escreve um caractere na tela e avança o cursor
        function writeChar(char) {
            if (cursor.y >= terminalRows) {
                scrollScreen();
                cursor.y = terminalRows - 1;
            }
            
            // Atualiza o buffer da tela
            screenData[cursor.y][cursor.x] = { char, fg: colors.fg, bg: colors.bg };
            
            // Desenha o caractere imediatamente
            drawChar(char, cursor.x, cursor.y, colors.fg, colors.bg);

            // Avança o cursor
            cursor.x++;
            if (cursor.x >= terminalCols) {
                cursor.x = 0;
                cursor.y++;
            }
            
            // Força o cursor a ser visível ao digitar
            cursor.visible = true;
            drawCursor(); // Desenha o cursor na nova posição
        }

        // Rola a tela inteira para cima em uma linha
        function scrollScreen() {
            // Move todas as linhas para cima
            for (let y = 0; y < terminalRows - 1; y++) {
                screenData[y] = screenData[y + 1];
            }
            
            // Cria uma nova linha vazia no final
            const newRow = [];
            for (let x = 0; x < terminalCols; x++) {
                newRow.push({ char: ' ', fg: colors.fg, bg: colors.bg });
            }
            screenData[terminalRows - 1] = newRow;
            
            // Redesenha a tela inteira após a rolagem
            drawScreen();
        }

        // Lida com teclas de controle (Enter, Backspace)
        function handleControlKeys(key) {
            switch (key) {
                case 'Enter':
                    processCommand(currentInputLine);
                    currentInputLine = ""; // Reseta o input
                    cursor.x = 0;
                    cursor.y++;
                    if (cursor.y >= terminalRows) {
                        scrollScreen();
                        cursor.y = terminalRows - 1;
                    }
                    writePrompt(); // Escreve o próximo prompt
                    break;
                
                case 'Backspace':
                    // Só permite apagar se estiver depois do prompt
                    if (cursor.x > promptX) {
                        cursor.x--;
                        writeChar(' '); // Escreve um espaço para apagar
                        cursor.x--; // Move o cursor de volta
                        currentInputLine = currentInputLine.slice(0, -1); // Remove do buffer de input
                    }
                    break;
            }
            drawCursor();
        }

        // --- Lógica de Comando e Input ---

        function writePrompt() {
            writeChar('>');
            writeChar(' ');
            promptX = cursor.x; // Define a posição de início do input
        }

        // Processa o comando digitado
        function processCommand(cmd) {
            const command = cmd.trim().toLowerCase();
            
            if (command === "config") {
                showConfigModal();
            }
            // Outros comandos podem ser adicionados aqui
        }

        // Dá foco ao input invisível (para teclado móvel)
        function focusHiddenInput() {
            if (isModalOpen) return;
            hiddenInput.focus();
        }

        // Manipulador principal de entrada de teclado
        function handleKeydown(e) {
            e.preventDefault();
            if (isModalOpen) return;

            const key = e.key;

            if (key.length === 1) {
                // É um caractere imprimível
                writeChar(key);
                currentInputLine += key; // Adiciona ao buffer de input
            } else {
                // É uma tecla de controle
                handleControlKeys(key);
            }
        }

        // --- Lógica do Modal de Configuração ---

        function showConfigModal() {
            isModalOpen = true;
            cursor.visible = false;
            drawScreen(); // Redesenha para esconder o cursor
            configModal.classList.remove('hidden');
        }

        function hideConfigModal() {
            isModalOpen = false;
            configModal.classList.add('hidden');
            focusHiddenInput(); // Devolve o foco ao terminal
        }

        // Aplica novas dimensões
        function applySettings() {
            const newRows = parseInt(rowsInput.value, 10);
            const newCols = parseInt(colsInput.value, 10);
            
            if (newRows > 0 && newCols > 0) {
                terminalRows = newRows;
                terminalCols = newCols;
                
                // Salva no localStorage
                localStorage.setItem('terminalDimensions', JSON.stringify({ rows: terminalRows, cols: terminalCols }));

                initializeTerminal(); // Reinicia o terminal com novas dimensões
            }
            hideConfigModal();
        }

        // Carrega um arquivo JSON de fonte
        function loadFont(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const newFont = JSON.parse(event.target.result);
                    // Validação simples
                    if (newFont.charWidth && newFont.charHeight && newFont.data) {
                        fontSet = newFont;
                        // Salva no localStorage
                        localStorage.setItem('terminalFont', JSON.stringify(fontSet));
                        console.log("Nova fonte carregada e salva.");
                        initializeTerminal(); // Reinicia imediatamente
                    } else {
                        alert("Arquivo de fonte JSON inválido. Formato esperado: { charWidth, charHeight, data: {...} }");
                    }
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON da fonte:", err.message);
                    alert("Erro ao ler o arquivo JSON: " + err.message);
                }
            };
            reader.readAsText(file);
        }

        // Carrega um arquivo JSON de cores
        function loadColors(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const newColors = JSON.parse(event.target.result);
                    // Mescla cores (permite arquivos parciais)
                    colors = { ...colors, ...newColors };
                    
                    // Salva no localStorage
                    localStorage.setItem('terminalColors', JSON.stringify(colors));
                    console.log("Novas cores carregadas e salvas.");
                    initializeTerminal(); // Reinicia imediatamente
                    
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON de cores:", err.message);
                    alert("Erro ao ler o arquivo JSON: " + err.message);
                }
            };
            reader.readAsText(file);
        }

    </script>
</body>
</html>

