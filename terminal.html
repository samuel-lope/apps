<!DOCTYPE html>
<html lang="pt-br" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal VT-100 ASCII</title>
    <!-- Carrega o TailwindCSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ... (estilos existentes de canvas, hiddenInput, keyframes) ... */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        #hiddenInput {
            position: absolute;
            top: -100px;
            left: -100px;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        .cursor-blink {
            animation: blink 1s step-start infinite;
        }
    </style>
</head>
<body class="font-mono text-gray-200 bg-gray-900 h-full overflow-hidden">

    <!-- NOVO: Indicador de Carregamento -->
    <div id="loadingIndicator" class="fixed inset-0 flex items-center justify-center bg-gray-900 text-white z-50">
        <p class="text-lg animate-pulse">Carregando terminal...</p>
    </div>

    <!-- Canvas do Terminal (agora oculto por padrão) -->
    <canvas id="terminalCanvas" class="w-screen h-screen bg-black cursor-text hidden"></canvas>

    <!-- ... (hiddenInput e configModal permanecem os mesmos) ... -->
    <input type="text" id="hiddenInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

    <div id="configModal" class="fixed inset-0 bg-black bg-opacity-80 backdrop-blur-sm overflow-y-auto py-10 hidden">
        <!-- Conteúdo do Modal (inalterado) -->
        <div class="relative w-full max-w-6xl mx-auto bg-gray-800 rounded-lg shadow-xl p-6">
            
            <button id="closeModalButton" class="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
            <h2 class="text-2xl font-bold text-white mb-6">Configurações do Terminal</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Card: Dimensões (inalterado) -->
                <div class="bg-gray-700 p-5 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4">Dimensões</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="rowsInput" class="block text-sm font-medium text-gray-300">Linhas (Rows)</label>
                            <input type="number" id="rowsInput" value="24" class="mt-1 block w-full bg-gray-800 border-gray-600 text-white rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div>
                            <label for="colsInput" class="block text-sm font-medium text-gray-300">Colunas (Cols)</label>
                            <input type="number" id="colsInput" value="80" class="mt-1 block w-full bg-gray-800 border-gray-600 text-white rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    </div>
                </div>

                <!-- Card: Personalização (inalterado) -->
                <div class="bg-gray-700 p-5 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4">Personalização</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="fontLoader" class="block text-sm font-medium text-gray-300">Carregar Fonte (JSON)</label>
                            <input type="file" id="fontLoader" accept=".json" class="mt-1 block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                        </div>
                        <div>
                            <label for="colorLoader" class="block text-sm font-medium text-gray-300">Carregar Cores (JSON)</label>
                            <input type="file" id="colorLoader" accept=".json" class="mt-1 block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                        </div>
                    </div>
                </div>

                <!-- Card: Formatos JSON (inalterado) -->
                <div class="bg-gray-700 p-5 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4">Formatos JSON Esperados</h3>
                    <p class="text-xs text-gray-400 mb-2">Use o código ASCII decimal como chave.</p>
                    <pre class="bg-gray-800 text-gray-300 p-3 rounded-md text-xs overflow-auto">
{
  "charWidth": 8,
  "charHeight": 8,
  "data": {
    "65": [
      "01111000",
      "..."
    ],
    "66": [ ... ]
  }
}
                    </pre>
                    <pre class="bg-gray-800 text-gray-300 p-3 rounded-md text-xs overflow-auto mt-2">
{
  "fg": "#FFFFFF",
  "bg": "#000000",
  "cursor": "#FFFFFF"
}
                    </pre>
                </div>
            </div>

            <!-- Botão de Aplicar (inalterado) -->
            <div class="mt-8 text-right">
                <button id="applyButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-150">
                    Aplicar e Fechar
                </button>
            </div>
        </div>
    </div>


    <script>
        // --- Elementos DOM ---
        const canvas = document.getElementById('terminalCanvas');
        const ctx = canvas.getContext('2d');
        const hiddenInput = document.getElementById('hiddenInput');
        const loadingIndicator = document.getElementById('loadingIndicator'); // NOVO
        
        // --- Elementos do Modal ---
        // ... (configModal, applyButton, etc. - inalterados) ...
        const configModal = document.getElementById('configModal');
        const applyButton = document.getElementById('applyButton');
        const closeModalButton = document.getElementById('closeModalButton');
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const fontLoader = document.getElementById('fontLoader');
        const colorLoader = document.getElementById('colorLoader');


        // --- Estado do Terminal ---
        let terminalRows = 24;
        let terminalCols = 80;
        
        // fontSet agora conterá a fonte PRÉ-PROCESSADA (com chaves de caractere)
        let fontSet = {
            charWidth: 8,
            charHeight: 8,
            data: {}
        };
        
        let colors = {
            fg: '#FFFFFF',
            bg: '#000000',
            cursor: '#FFFFFF'
        };

        // Fallback de emergência (ATUALIZADO para usar chaves de caractere)
        const emergencyFont = {
            charWidth: 8,
            charHeight: 8,
            data: {
                " ": [ "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000" ],
                "?": [ "00111100", "01000010", "01000010", "00000100", "00011000", "00000000", "00011000", "00000000" ]
            }
        };

        // ... (screenData, cursor, etc. - inalterados) ...
        let screenData = [];
        let cursor = { x: 0, y: 0, visible: true };
        let blinkInterval;
        let isModalOpen = false;
        let currentInputLine = "";
        let promptX = 2;


        // --- Inicialização ---

        // Carrega as configurações (ou JSON padrão) e inicia o terminal
        window.onload = async () => {
            try {
                await loadSettingsFromStorage();
            } catch (err) {
                console.error("Falha ao carregar configurações ou fonte padrão:", err);
                fontSet = emergencyFont; // Usa a fonte de emergência (já processada)
            }
            
            initializeTerminal();

            // --- NOVO: Lógica de Exibição ---
            // Esconde o loading e mostra o terminal
            loadingIndicator.classList.add('hidden');
            canvas.classList.remove('hidden');
            
            // Foca para input de teclado desktop
            focusHiddenInput();

            // Event Listeners Globais
            window.addEventListener('resize', resizeCanvasDisplay);
            canvas.addEventListener('click', focusHiddenInput);
            hiddenInput.addEventListener('keydown', handleKeydown);

            // Listeners do Modal
            applyButton.addEventListener('click', applySettings);
            closeModalButton.addEventListener('click', hideConfigModal);
            fontLoader.addEventListener('change', loadFont);
            colorLoader.addEventListener('change', loadColors);
        };

        // NOVO: Pré-processa a fonte de chaves ASCII para chaves de caractere
        function processFont(rawFont) {
            const processedData = {};
            // Itera sobre as chaves (ex: "65")
            for (const asciiCode in rawFont.data) {
                // Converte a chave "65" para o caractere "A"
                const char = String.fromCharCode(parseInt(asciiCode, 10));
                // Armazena no novo objeto: processedData["A"] = [...]
                processedData[char] = rawFont.data[asciiCode];
            }
            
            // Retorna a estrutura da fonte, mas com os dados processados
            return {
                charWidth: rawFont.charWidth,
                charHeight: rawFont.charHeight,
                data: processedData
            };
        }

        // Carrega configurações do localStorage ou busca a fonte padrão
        async function loadSettingsFromStorage() {
            // ... (Carregar Dimensões e Cores - inalterado) ...
            const savedDims = localStorage.getItem('terminalDimensions');
            if (savedDims) {
                const { rows, cols } = JSON.parse(savedDims);
                terminalRows = rows;
                terminalCols = cols;
            }
            rowsInput.value = terminalRows;
            colsInput.value = terminalCols;

            const savedColors = localStorage.getItem('terminalColors');
            if (savedColors) {
                colors = { ...colors, ...JSON.parse(savedColors) };
            }


            // 3. Carregar Fonte (ATUALIZADO com processamento)
            const savedFont = localStorage.getItem('terminalFont');
            if (savedFont) {
                // Processa a fonte do localStorage
                fontSet = processFont(JSON.parse(savedFont));
                console.log("Fonte processada do localStorage.");
            } else {
                // Se não houver fonte salva, busca a padrão
                console.log("Buscando defaultFont.json...");
                const response = await fetch('defaultFont.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawFont = await response.json();
                // Processa a fonte baixada
                fontSet = processFont(rawFont);
                console.log("Fonte padrão carregada e processada.");
            }
        }
        
        // (Re)Inicia o terminal com as configurações atuais
        function initializeTerminal() {
            // ... (código de inicialização inalterado) ...
            canvas.width = terminalCols * fontSet.charWidth;
            canvas.height = terminalRows * fontSet.charHeight;
            resizeCanvasDisplay();
            screenData = [];
            for (let y = 0; y < terminalRows; y++) {
                const row = [];
                for (let x = 0; x < terminalCols; x++) {
                    row.push({ char: ' ', fg: colors.fg, bg: colors.bg });
                }
                screenData.push(row);
            }
            cursor.x = 0;
            cursor.y = 0;
            writePrompt();
            if (blinkInterval) clearInterval(blinkInterval);
            blinkInterval = setInterval(toggleCursor, 500);
            drawScreen();
        }

        // --- Lógica de Renderização (Canvas) ---

        // ... (resizeCanvasDisplay e drawScreen - inalterados) ...
        function resizeCanvasDisplay() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            canvas.style.width = `${viewportWidth}px`;
            canvas.style.height = `${viewportHeight}px`;
        }

        function drawScreen() {
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < terminalRows; y++) {
                for (let x = 0; x < terminalCols; x++) {
                    const cell = screenData[y][x];
                    if (cell.char !== ' ' || cell.bg !== colors.bg) {
                         drawChar(cell.char, x, y, cell.fg, cell.bg);
                    }
                }
            }
            if (cursor.visible && !isModalOpen) {
                drawCursor();
            }
        }
        
        // Desenha um único caractere na grade (ATUALIZADO)
        function drawChar(char, x, y, fg, bg) {
            // A MÁGICA DA OTIMIZAÇÃO:
            // A busca agora é direta, sem NENHUMA conversão.
            const charData = fontSet.data[char] || fontSet.data["?"]; // Usa "?" como fallback
            
            if (!charData) return; // Caractere não encontrado

            const startX = x * fontSet.charWidth;
            const startY = y * fontSet.charHeight;

            // ... (lógica de desenho de pixel inalterada) ...
            ctx.fillStyle = bg;
            ctx.fillRect(startX, startY, fontSet.charWidth, fontSet.charHeight);
            ctx.fillStyle = fg;
            for (let row = 0; row < fontSet.charHeight; row++) {
                if (!charData[row]) continue;
                for (let col = 0; col < fontSet.charWidth; col++) {
                    if (charData[row][col] === '1') {
                        ctx.fillRect(startX + col, startY + row, 1, 1);
                    }
                }
            }
        }

        // ... (drawCursor, toggleCursor, writeChar, scrollScreen, handleControlKeys) ...
        // ... (writePrompt, processCommand, focusHiddenInput, handleKeydown) ...
        // ... (showConfigModal, hideConfigModal, applySettings) ...
        // (Todas as funções acima permanecem inalteradas)
        
        function drawCursor() {
            const x = cursor.x * fontSet.charWidth;
            const y = cursor.y * fontSet.charHeight;
            ctx.fillStyle = colors.cursor;
            ctx.fillRect(x, y + fontSet.charHeight - 2, fontSet.charWidth, 2);
        }
        
        function toggleCursor() {
            if (isModalOpen) {
                cursor.visible = false;
                drawScreen();
                return;
            }
            cursor.visible = !cursor.visible;
            const cell = screenData[cursor.y][cursor.x];
            drawChar(cell.char, cursor.x, cursor.y, cell.fg, cell.bg);
            if (cursor.visible) {
                drawCursor();
            }
        }

        function writeChar(char) {
            if (cursor.y >= terminalRows) {
                scrollScreen();
                cursor.y = terminalRows - 1;
            }
            screenData[cursor.y][cursor.x] = { char, fg: colors.fg, bg: colors.bg };
            drawChar(char, cursor.x, cursor.y, colors.fg, colors.bg);
            cursor.x++;
            if (cursor.x >= terminalCols) {
                cursor.x = 0;
                cursor.y++;
            }
            cursor.visible = true;
            drawCursor();
        }

        function scrollScreen() {
            for (let y = 0; y < terminalRows - 1; y++) {
                screenData[y] = screenData[y + 1];
            }
            const newRow = [];
            for (let x = 0; x < terminalCols; x++) {
                newRow.push({ char: ' ', fg: colors.fg, bg: colors.bg });
            }
            screenData[terminalRows - 1] = newRow;
            drawScreen();
        }

        function handleControlKeys(key) {
            switch (key) {
                case 'Enter':
                    processCommand(currentInputLine);
                    currentInputLine = "";
                    cursor.x = 0;
                    cursor.y++;
                    if (cursor.y >= terminalRows) {
                        scrollScreen();
                        cursor.y = terminalRows - 1;
                    }
                    writePrompt();
                    break;
                case 'Backspace':
                    if (cursor.x > promptX) {
                        cursor.x--;
                        writeChar(' ');
                        cursor.x--;
                        currentInputLine = currentInputLine.slice(0, -1);
                    }
                    break;
            }
            drawCursor();
        }

        function writePrompt() {
            writeChar('>');
            writeChar(' ');
            promptX = cursor.x;
        }

        function processCommand(cmd) {
            const command = cmd.trim().toLowerCase();
            if (command === "config") {
                showConfigModal();
            }
        }

        function focusHiddenInput() {
            if (isModalOpen) return;
            hiddenInput.focus();
        }

        function handleKeydown(e) {
            e.preventDefault();
            if (isModalOpen) return;
            const key = e.key;
            if (key.length === 1) {
                writeChar(key);
                currentInputLine += key;
            } else {
                handleControlKeys(key);
            }
        }

        function showConfigModal() {
            isModalOpen = true;
            cursor.visible = false;
            drawScreen();
            configModal.classList.remove('hidden');
        }

        function hideConfigModal() {
            isModalOpen = false;
            configModal.classList.add('hidden');
            focusHiddenInput();
        }

        function applySettings() {
            const newRows = parseInt(rowsInput.value, 10);
            const newCols = parseInt(colsInput.value, 10);
            if (newRows > 0 && newCols > 0) {
                terminalRows = newRows;
                terminalCols = newCols;
                localStorage.setItem('terminalDimensions', JSON.stringify({ rows: terminalRows, cols: terminalCols }));
                initializeTerminal();
            }
            hideConfigModal();
        }


        // Carrega um arquivo JSON de fonte (ATUALIZADO)
        function loadFont(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const rawFont = JSON.parse(event.target.result); // Fonte crua
                    // Validação
                    if (rawFont.charWidth && rawFont.charHeight && rawFont.data) {
                        // Processa a fonte crua para o formato otimizado
                        fontSet = processFont(rawFont); 
                        
                        // Salva a fonte CRUA (ASCII-keyed) no localStorage
                        localStorage.setItem('terminalFont', JSON.stringify(rawFont));
                        
                        console.log("Nova fonte carregada, processada e salva.");
                        initializeTerminal(); // Reinicia imediatamente
                    } else {
                        alert("Arquivo de fonte JSON inválido. Formato esperado: { charWidth, charHeight, data: {...} }");
                    }
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON da fonte:", err.message);
                    alert("Erro ao ler o arquivo JSON: " + err.message);
                }
            };
            reader.readAsText(file);
        }

        // ... (loadColors - inalterado) ...
        function loadColors(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const newColors = JSON.parse(event.target.result);
                    colors = { ...colors, ...newColors };
                    localStorage.setItem('terminalColors', JSON.stringify(colors));
                    console.log("Novas cores carregadas e salvas.");
                    initializeTerminal();
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON de cores:", err.message);
                    alert("Erro ao ler o arquivo JSON: " + err.message);
                }
            };
            reader.readAsText(file);
        }

    </script>
</body>
</html>

